# -*- coding: utf-8 -*-
"""AI Assignment #1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1USCESc9z5DfALfAB2c_3SZ_9aFNT8iFA

# BFS VS DFS

This Colab Notebook tries implementing maze solving using breadth first search and depth first search and tries to compare the performance of both algorithms
"""

maze0 = [
        [1,1,1,0],
        [0,0,1,1],
        [0,0,1,1],
]
start0 = (0,0)
target0 = (2,3)
maze1 = [
        [1,1,1,0,0,0,0,0,0],
        [0,1,1,1,0,0,0,0,0],
        [0,1,1,1,1,1,1,1,1],
        [0,1,1,1,1,1,1,1,1],
]

start1 = (3,9)
target1 = (0,1)

maze2 = [
    [1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1],
    [1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1],
    [1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1],
    [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1],
    [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0],
    [1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1],
    [1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1],
    [1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1]
]

start2 = (0, 0)
target2 = (4, 19)

from collections import deque
import time

def is_valid_move(maze, row, col):

  if len(maze)>row and len(maze[row])>col and row>=0 and col>=0:
      if maze[row][col]==1: return True
  return False

def get_negihbors(maze,state):
    negihbors=[]
    for x in range(state[0]-1,state[0]+2,2):
        if is_valid_move(maze,x,state[1]):
            negihbors.append((x,state[1]))
    for x in range(state[1]-1,state[1]+2,2):
        if is_valid_move(maze,state[0],x):
            negihbors.append((state[0],x))
    return negihbors

def bfs(maze, start, target):
    frontier = deque()
    frontier.appendleft(start)
    child_parent_pairs={}
    explored = []
    while len(frontier)>0:
        state = frontier.pop()
        explored.append(state)
        if state == target :
             path = []
             path.append(state)
             while(child_parent_pairs.get(state) is not None):
                 state=child_parent_pairs[state]
                 path.append(state)
             return path
        neighbors = get_negihbors(maze,state)
        for neighbor in neighbors:
            if neighbor not in frontier and neighbor not in explored:
                child_parent_pairs[neighbor] = state
                frontier.appendleft(neighbor)

    return None

def dfs(maze, current, target, visited=None, path=None):
    if visited is None:
        visited = set()
    if path is None:
        path = []
    visited.add(current)


    path.append(current)
    if current == target:
        return path
    neighbors = get_negihbors(maze, current)

    for neighbor in neighbors:
        if neighbor not in visited and maze[neighbor[0]][neighbor[1]] == 1:
            result = dfs(maze, neighbor, target, visited, path)

            if result is not None:
                return result

    path.pop()
    return None

def evalutate():

    average_time = None
    average_path_length = 0


    print("MAZE 0:")
    bfs_time_start =time.time()
    bfs_path = bfs(maze0,start0,target0)
    bfs_time_end =time.time()
    bfs_time_taken = bfs_time_end - bfs_time_start
    bfs_number_of_nodes_visited= len(bfs_path)
    print("BFS")
    print("Time Taken: ", bfs_time_taken)
    print("Path Length: ", bfs_number_of_nodes_visited)
    print("Shortest Path: ",bfs_path)
    dfs_time_start =time.time()
    dfs_explored = dfs(maze0,start0,target0)
    dfs_time_end =time.time()
    dfs_time_taken = dfs_time_end - dfs_time_start
    dfs_number_of_nodes_visited= len(dfs_explored)
    print("DFS")
    print("Time Taken: ", dfs_time_taken)
    print("Path Length: ", dfs_number_of_nodes_visited)
    print("Shortest Path: ", dfs_explored)

    print("--------------------------------------------")

    print("MAZE 1:")
    bfs_time_start =time.time()
    bfs_path = bfs(maze1,start1,target1)
    bfs_time_end =time.time()
    bfs_time_taken = bfs_time_end - bfs_time_start
    bfs_number_of_nodes_visited= len(bfs_path)
    print("BFS")
    print("Time Taken: ", bfs_time_taken)
    print("Path Length: ", bfs_number_of_nodes_visited)
    print("Shortest Path: ",bfs_path)
    dfs_time_start =time.time()
    dfs_explored = dfs(maze1,start1,target1)
    dfs_time_end =time.time()
    dfs_time_taken = dfs_time_end - dfs_time_start
    dfs_number_of_nodes_visited= len(dfs_explored)
    print("DFS")
    print("Time Taken: ", dfs_time_taken)
    print("Path Length: ", dfs_number_of_nodes_visited)
    print("Shortest Path: ", dfs_explored)



    print("--------------------------------------------")


    print("MAZE 2:")
    bfs_time_start =time.time()
    bfs_path = bfs(maze2,start2,target2)
    bfs_time_end =time.time()
    bfs_time_taken = bfs_time_end - bfs_time_start
    bfs_number_of_nodes_visited= len(bfs_path)
    print("BFS")
    print("Time Taken: ", bfs_time_taken)
    print("Path Length: ", bfs_number_of_nodes_visited)
    print("Shortest Path: ",bfs_path)
    dfs_time_start =time.time()
    dfs_explored = dfs(maze2,start2,target2)
    dfs_time_end =time.time()
    dfs_time_taken = dfs_time_end - dfs_time_start
    dfs_number_of_nodes_visited= len(dfs_explored)
    print("DFS")
    print("Time Taken: ", dfs_time_taken)
    print("Path Length: ", dfs_number_of_nodes_visited)
    print("Shortest Path: ", dfs_explored)

evalutate()

"""# Conclusion:
From the results above we can conclude following things:



*   Breadth First Search Algorithm is much more faster and Time Efficient than Depth First Search Algorithm
*   Depth First Search Algorithm does not always provide the optimal solution






"""